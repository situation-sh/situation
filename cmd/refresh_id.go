package cmd

import (
	"bytes"
	"os"
	"path/filepath"

	"github.com/google/uuid"
	"github.com/minio/selfupdate"
	"github.com/situation-sh/situation/config"
	"github.com/urfave/cli/v2"
)

var refreshIDCmd = cli.Command{
	Name:  "refresh-id",
	Usage: "Regenerate the internal ID of the agent",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:     "uuid",
			Required: false,
			Value:    uuid.NewString(),
			Usage:    "Optional UUID to insert into the binary (randomly generated by default)",
		},
	},
	Action: runRefreshIDCmd,
}

func runRefreshIDCmd(c *cli.Context) error {
	u, err := uuid.Parse(c.String("uuid"))
	if err != nil {
		return err
	}

	newBytes, err := u.MarshalBinary()
	if err != nil {
		return err
	}

	// get the path to the current executable
	binaryFile, err := os.Executable()
	if err != nil {
		return err
	}
	binaryFile = filepath.Clean(binaryFile)

	// see https://pkg.go.dev/os#Executable
	binaryFile, err = filepath.EvalSymlinks(binaryFile)
	if err != nil {
		return err
	}

	// file exist
	if _, err := os.Stat(binaryFile); err != nil {
		return err
	}

	raw, err := os.ReadFile(binaryFile) //#nosec (https://github.com/securego/gosec/issues/821)
	if err != nil {
		return err
	}

	// set a new random ID
	toWrite := bytes.Replace(raw, config.ID[:16], newBytes[:16], 1)
	// turn toWrite into is.Reader
	if err := selfupdate.Apply(bytes.NewReader(toWrite), selfupdate.Options{}); err != nil {
		return err
	}

	// update the context
	// this context is sent to the AfterFunc
	// c.Context = context.WithValue(c.Context, contextConfigKey("binaryFile"), binaryFile)
	// c.Context = context.WithValue(c.Context, contextConfigKey("tmpFile"), tmpFile)

	return nil
}

func init() {
	app.Commands = append(app.Commands, &refreshIDCmd)
}
