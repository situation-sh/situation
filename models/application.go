package models

import (
	"net"

	// "github.com/iancoleman/orderedmap"
	"github.com/invopop/jsonschema"
	orderedmap "github.com/wk8/go-ordered-map/v2"
)

// Package is a wrapper around application that stores distribution
// information of applications (executables)
type Package struct {
	Name            string         `json:"name,omitempty" jsonschema:"description=name of the package,example=openssh,example=musl-gcc,example=python,example=texlive"`
	Version         string         `json:"version,omitempty" jsonschema:"description=version of the package,example=8.8p1,example=1.2.3,example=3.10.8,example=2021"`
	Vendor          string         `json:"vendor,omitempty" jsonschema:"description=name of the organization that produce the package or its maintainer,example=Fedora Project,example=bob@debian.org"`
	Manager         string         `json:"manager,omitempty" jsonschema:"description=program that manages the package installation,example=rpm,example=dpkg,example=msi,example=builtin"`
	InstallTimeUnix int64          `json:"install_time,omitempty" jsonschema:"description=UNIX timestamp of the package installation,example=1670520587"`
	Applications    []*Application `json:"applications" jsonschema:"description=list of the applications provided by this package"`
	Files           []string       `json:"-"` // ignore that field for the moment
}

func NewPackage() *Package {
	return &Package{
		Applications: make([]*Application, 0),
		Files:        make([]string, 0),
	}
}

// Equal check if two packages are the same. Here we assume
// that Name and Version must be set
func (pkg *Package) Equal(other *Package) bool {
	if !(pkg.Name == other.Name && len(pkg.Name) > 0) {
		return false
	}
	if !(pkg.Version == other.Version && len(pkg.Version) > 0) {
		return false
	}
	if pkg.Vendor != other.Vendor {
		return false
	}
	if pkg.Manager != other.Manager {
		return false
	}
	return true
}

// ApplicationNames return the names of the apps that are
// attached to the package
func (pkg *Package) ApplicationNames() []string {
	if len(pkg.Applications) == 0 {
		return []string{}
	}
	out := make([]string, len(pkg.Applications))
	for i, a := range pkg.Applications {
		out[i] = a.Name
	}
	return out
}

// Application is a structure that represents all the
// types of apps we can have on a system
type Application struct {
	Name      string                 `json:"name,omitempty" jsonschema:"description=path (or name) of the application,example=/usr/sbin/sshd,example=/usr/bin/musl-gcc,example=C:\\Windows\\System32\\svchost.exe,example=wininit.exe,example=System"`
	Args      []string               `json:"args,omitempty" jsonschema:"description=list of arguments passed to app"` // we cannot put example right now (PR in progress: https://github.com/invopop/jsonschema/pull/31)
	Endpoints []*ApplicationEndpoint `json:"endpoints" jsonschema:"description=list of network endpoints open by this app"`
	PID       uint                   `json:"pid,omitempty" jsonschema:"description=processus ID,example=5452,example=19420"`
	Flows     []*Flow                `json:"flows" jsonschema:"description=list of flows generated by this app"`
}

func NewApplication() *Application {
	return &Application{
		Endpoints: make([]*ApplicationEndpoint, 0),
		Flows:     make([]*Flow, 0),
	}
}

// Flow aims to represent a layer 4 connection
type Flow struct {
	LocalAddr  net.IP `json:"local_addr"`
	LocalPort  uint16 `json:"local_port"`
	RemoteAddr net.IP `json:"remote_addr"`
	RemotePort uint16 `json:"remote_port"`
	Protocol   string `json:"protocol"`
	Status     string `json:"status"`
}

// ApplicationEndpoint is a structure used by Application
// to tell that the app listens on given addr and port
type ApplicationEndpoint struct {
	Port     uint16 `json:"port"`
	Protocol string `json:"protocol"`
	Addr     net.IP `json:"addr"`
}

func (s *Application) lastEndpoint() *ApplicationEndpoint {
	if len(s.Endpoints) == 0 {
		return nil
	}
	return s.Endpoints[len(s.Endpoints)-1]
}

// AddEndpoint appends a new endpoint if it does exist yet
// It returns true if a new endpoint has been added
func (s *Application) AddEndpoint(addr net.IP, port uint16, proto string) (*ApplicationEndpoint, bool) {
	// check if it exist
	for _, e := range s.Endpoints {
		if e.Port == port && e.Protocol == proto {
			// case where the application already listens to 0.0.0.0 (or ::)
			if e.Addr.IsUnspecified() {
				return e, false
			}
			// case where the incoming endpoint is unspecified
			// so it must encompass the first
			if addr.IsUnspecified() {
				copy(e.Addr, addr)
				return e, false
			}
		}
	}

	s.Endpoints = append(s.Endpoints,
		&ApplicationEndpoint{Addr: addr, Port: port, Protocol: proto})

	return s.lastEndpoint(), true
}

func (ApplicationEndpoint) JSONSchema() *jsonschema.Schema {
	properties := orderedmap.New[string, *jsonschema.Schema]()
	properties.Set("port", &jsonschema.Schema{
		Type:        "integer",
		Maximum:     "65535",
		Minimum:     "1",
		Description: "port",
		Examples: []interface{}{
			22,
			80,
			443,
			49667,
		},
	})

	properties.Set("protocol", &jsonschema.Schema{
		Type:        "string",
		Description: "transport layer protocol",
		Examples: []interface{}{
			"tcp",
			"udp",
		},
	})

	properties.Set("addr", &jsonschema.Schema{
		Title: "IPv4 or IPv6 address",
		AnyOf: []*jsonschema.Schema{
			{Type: "string", Format: "ipv4"},
			{Type: "string", Format: "ipv6"},
		},
		Description: "binding IP address",
		Examples: []interface{}{
			"192.168.10.103",
			"0.0.0.0",
			"::",
			"fe80::c1b2:a320:f799:10e0",
		},
	})

	return &jsonschema.Schema{
		Properties:           properties,
		AdditionalProperties: jsonschema.FalseSchema,
		Type:                 "object",
		Required:             []string{"port", "protocol", "addr"},
	}
}

func (Flow) JSONSchema() *jsonschema.Schema {
	properties := orderedmap.New[string, *jsonschema.Schema]()

	for _, prop := range []string{"local_port", "remote_port"} {
		properties.Set(prop, &jsonschema.Schema{
			Type:        "integer",
			Maximum:     "65535",
			Minimum:     "1",
			Description: "port",
			Examples: []interface{}{
				22,
				80,
				443,
				49667,
			},
		})
	}

	for _, prop := range []string{"local_addr", "remote_addr"} {
		properties.Set(prop, &jsonschema.Schema{
			Title: "IPv4 or IPv6 address",
			AnyOf: []*jsonschema.Schema{
				{Type: "string", Format: "ipv4"},
				{Type: "string", Format: "ipv6"},
			},
			Description: "binding IP address",
			Examples: []interface{}{
				"192.168.10.103",
				"0.0.0.0",
				"::",
				"fe80::c1b2:a320:f799:10e0",
			},
		})
	}

	properties.Set("protocol", &jsonschema.Schema{
		Type:        "string",
		Description: "transport layer protocol",
		Examples: []interface{}{
			"tcp",
			"udp",
		},
	})

	properties.Set("status", &jsonschema.Schema{
		Type:        "string",
		Description: "Link status",
		Examples: []interface{}{
			"CLOSE_WAIT",
			"ESTABLISHED",
		},
	})

	return &jsonschema.Schema{
		Properties:           properties,
		AdditionalProperties: jsonschema.FalseSchema,
		Type:                 "object",
		Required:             []string{"local_port", "local_addr", "remote_port", "remote_addr", "protocol", "status"},
	}
}
