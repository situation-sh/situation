{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Situation is a project that aims to discover everything on information systems, on its own. In a way, it lies between nmap , telegraf and osquery . However it mainly differs from them on the following aspect: user do not declare what to collect or where . When we run tools like nmap or telegraf , we know the targets (ex: a subnetwork, a specific service...) and we must configure the tool in this way. situation aims to run without prior knowledge and this philosophy has two advantages: frictionless deployment (single binary, just download and run) no blind spots (who knows exactly what runs on his/her system?) Situation is bound to collect data, nothing more. To go further, situation provides a json schema for the output data. Situation is an early-stage project. It currently targets Linux and Windows but keep in mind that it has not been tested on all the machines on Earth. It does not mean that is a dangerous codebase, only that it may fail.","title":"Situation"},{"location":"backends/","text":"The collected data can be sent to different endpoints, a.k.a. backends. Stdout The simplest way to show what situation ahs collected is to print the final payload to stdout. Linux situation --stdout Windows situation . exe - -stdout File The payload can also be stored in a file. Linux situation --file --file-path = /tmp/situation.json Windows situation . exe - -file - -file -path = \"C:\\Users\\situation.json\" HTTP Finally, the http backend is very convenient to send the payload (json) directly to a remote server. Linux situation --http --http-url = http://localhost:8000/situation/ --http-extra-header = \"X-API-Key=d50deba3-6183-425a-b35c-ef0e030c284e\" Windows situation . exe - -http - -http-url = http :// localhost : 8000 / situation / - -http-extra-header = \"X-API-Key=d50deba3-6183-425a-b35c-ef0e030c284e\" By default it uses the POST method, but you can also use PUT by using the --http-method option. Also, it embeds a default authorization header, filled with the agent id: Authorization: <agent-id> (can be modified with the --http-authorization flag)","title":"Backends"},{"location":"backends/#stdout","text":"The simplest way to show what situation ahs collected is to print the final payload to stdout. Linux situation --stdout Windows situation . exe - -stdout","title":"Stdout"},{"location":"backends/#file","text":"The payload can also be stored in a file. Linux situation --file --file-path = /tmp/situation.json Windows situation . exe - -file - -file -path = \"C:\\Users\\situation.json\"","title":"File"},{"location":"backends/#http","text":"Finally, the http backend is very convenient to send the payload (json) directly to a remote server. Linux situation --http --http-url = http://localhost:8000/situation/ --http-extra-header = \"X-API-Key=d50deba3-6183-425a-b35c-ef0e030c284e\" Windows situation . exe - -http - -http-url = http :// localhost : 8000 / situation / - -http-extra-header = \"X-API-Key=d50deba3-6183-425a-b35c-ef0e030c284e\" By default it uses the POST method, but you can also use PUT by using the --http-method option. Also, it embeds a default authorization header, filled with the agent id: Authorization: <agent-id> (can be modified with the --http-authorization flag)","title":"HTTP"},{"location":"configuration/","text":"What??? You said zero-config ! Yes by default, there is no configuration. However one may tweak a little bit the agent so as to fulfil some specific needs. Scans You can configure the number of scans to perform and the waiting time between two scans using the following options: --scans value : Number of scans to perform (default: 1) --period value : Waiting time between two scans (default: 1m0s) Disabling modules All the module can be disabled through the following pattern --no-module-<module-name> (see the list of available modules ) Note As some modules may depend on others, disabling a module may lead to a cascasding effect. To force modules that depend on it to run, you must pass the --skip-missing-deps flag. situation --stdout --no-module-ping --skip-missing-deps Module configuration Some modules may expose specific option through flags. Do not hesitate to look at them in the help. For example: situation --stdout --snmp-community = local","title":"Configuration"},{"location":"configuration/#scans","text":"You can configure the number of scans to perform and the waiting time between two scans using the following options: --scans value : Number of scans to perform (default: 1) --period value : Waiting time between two scans (default: 1m0s)","title":"Scans"},{"location":"configuration/#disabling-modules","text":"All the module can be disabled through the following pattern --no-module-<module-name> (see the list of available modules ) Note As some modules may depend on others, disabling a module may lead to a cascasding effect. To force modules that depend on it to run, you must pass the --skip-missing-deps flag. situation --stdout --no-module-ping --skip-missing-deps","title":"Disabling modules"},{"location":"configuration/#module-configuration","text":"Some modules may expose specific option through flags. Do not hesitate to look at them in the help. For example: situation --stdout --snmp-community = local","title":"Module configuration"},{"location":"installation/","text":"Releases The agent currently supports Linux and Windows on x86_64 architectures. The binaries are made available through github releases . wget wget -qO situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation curl curl -sLo ./situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation PowerShell Invoke-RestMethod -OutFile situation . exe -Uri https :// github . com / situation-sh / situation / releases / download / v0 . 19 . 2 / situation - 0 . 19 . 2-amd64-windows . exe From sources As the agent makes use of generics, you need to have the go compiler >=1.18 go install github.com/situation-sh/situation Pre-built binaries are compiled with extra flags to reduce the binary size and also set the version inside the binary. See the Makefile for more details. The $GOPATH/bin folder must be in your PATH to run situation directly from the command line","title":"Installation"},{"location":"installation/#releases","text":"The agent currently supports Linux and Windows on x86_64 architectures. The binaries are made available through github releases . wget wget -qO situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation curl curl -sLo ./situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation PowerShell Invoke-RestMethod -OutFile situation . exe -Uri https :// github . com / situation-sh / situation / releases / download / v0 . 19 . 2 / situation - 0 . 19 . 2-amd64-windows . exe","title":"Releases"},{"location":"installation/#from-sources","text":"As the agent makes use of generics, you need to have the go compiler >=1.18 go install github.com/situation-sh/situation Pre-built binaries are compiled with extra flags to reduce the binary size and also set the version inside the binary. See the Makefile for more details. The $GOPATH/bin folder must be in your PATH to run situation directly from the command line","title":"From sources"},{"location":"quick_start/","text":"Run You guess it. To run the agent, you don't need to provide any extra configuration. Linux situation --stdout Windows situation . exe - -stdout You will see the json output in the terminal. So what you should do next, is to pipe that json to another tool (like jq see in the guide ). Update The agent can update itself. It queries Github releases and check if there is a newer version. Linux situation update Windows situation . exe update If the new version has breaking changes (when the major version is different) you should pass the --force flag to make the update. Other commands Command Description refresh-id Regenerate the internal ID of the agent defaults , def Print the default config id Print the identifier of the agent schema Print the JSON schema of the data exported by this agent version Print the version of the agent","title":"Quick start"},{"location":"quick_start/#run","text":"You guess it. To run the agent, you don't need to provide any extra configuration. Linux situation --stdout Windows situation . exe - -stdout You will see the json output in the terminal. So what you should do next, is to pipe that json to another tool (like jq see in the guide ).","title":"Run"},{"location":"quick_start/#update","text":"The agent can update itself. It queries Github releases and check if there is a newer version. Linux situation update Windows situation . exe update If the new version has breaking changes (when the major version is different) you should pass the --force flag to make the update.","title":"Update"},{"location":"quick_start/#other-commands","text":"Command Description refresh-id Regenerate the internal ID of the agent defaults , def Print the default config id Print the identifier of the agent schema Print the JSON schema of the data exported by this agent version Print the version of the agent","title":"Other commands"},{"location":"roadmap/","text":"Data exhaustiveness is crucial so the main axis is to develop more modules. You can have a look to the ongoing issues .","title":"Roadmap"},{"location":"10_guides/ansible/","text":"Agents can be deployed automatically through Ansible . Given an inventory you can run the playbook given below. ansible-playbook situation.yml -i inventory.yml The playbook can we tuned to customize where the agent will be installed. First it downloads locally the latest linux and windows binaries. Then it deploys the binaries to the hosts defined in the inventory and outputs a list of agentds deployed. # situation.yml - name : Download latest binaries (once) hosts : localhost gather_facts : false vars : repo : \"situation-sh/situation\" download_dir : \"{{ TMP_DIR | default('/tmp/situation') }}\" tasks : - name : Ensure download directory exists file : path : \"{{ download_dir }}\" state : directory - name : Get latest release from GitHub API uri : url : \"https://api.github.com/repos/situation-sh/situation/releases/latest\" return_content : true headers : Accept : \"application/vnd.github+json\" register : latest_release - name : Download matched release assets get_url : url : \"{{ item.browser_download_url }}\" dest : \"{{ download_dir }}/{{ item.name }}\" mode : \"0644\" loop : \"{{ latest_release.json.assets }}\" when : (\"-linux\" in item.name or \"-windows.exe\" in item.name) and (not lookup('file', download_dir + '/' + item.name, errors='ignore')) - name : Deploy agents to hosts tags : deploy hosts : all gather_facts : false vars : src_dir : \"{{ TMP_DIR | default('/tmp/situation') }}\" api_key : \"{{ SITUATION_API_KEY | default('') }}\" dest_linux : \"~/situation\" dest_windows : \"~/situation.exe\" agent_ids : \"{{ src_dir }}/agents.txt\" tasks : - name : Filter and return only selected facts ansible.builtin.setup : filter : - \"ansible_system\" - \"ansible_os_family\" - \"ansible_hostname\" - set_fact : is_windows : >- {{ ansible_os_family == \"Windows\" }} is_linux : >- {{ ansible_system == \"Linux\" }} - name : Copy Linux binary to target copy : src : \"{{ src_dir }}/{{ item }}\" dest : \"{{ dest_linux }}\" mode : \"0755\" loop : \"{{ lookup('fileglob', src_dir + '/*-linux', wantlist=True) | map('basename') | list }}\" when : is_linux - name : Copy Windows binary to target win_copy : src : \"{{ src_dir }}/{{ item }}\" dest : \"{{ dest_windows }}\" loop : \"{{ lookup('fileglob', src_dir + '/*-windows.exe', wantlist=True) | map('basename') | list }}\" when : is_windows - name : Define situation set_fact : situation : >- {{ dest_windows if is_windows else dest_linux }} - name : Refresh agent id win_command : \"{{ situation }} refresh-id\" when : is_windows - name : Refresh agent id command : \"{{ situation }} refresh-id\" when : is_linux - name : Print new id win_command : \"{{ situation }} id\" when : is_windows register : id_output_windows - name : Print new id command : \"{{ situation }} id\" when : is_linux register : id_output_linux - name : Retrieve new agent id set_fact : agent_id : >- {{ id_output_windows.stdout_lines[0] if is_windows else id_output_linux.stdout_lines[0] }} - name : List all deployments local_action : module : lineinfile line : \"{{ ansible_hostname }},{{ agent_id }}\" path : \"{{ agent_ids }}\" create : yes situation.sh If you use the situation.sh platform you must authorize the deployed agents.","title":"Ansible"},{"location":"10_guides/ansible/#situationsh","text":"If you use the situation.sh platform you must authorize the deployed agents.","title":"situation.sh"},{"location":"10_guides/fastapi/","text":"In this guide, we build a backend able to receive the payload from Situation. This backend is a simple FastAPI application that will print the payload to stdout. Requirements Initialize a project with uv for instance. uv init situation-fastapi cd situation-fastapi Add some dependencies: uv add 'fastapi[standard]' First steps Create a file main.py with the following content: # main.py from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI () @app . get ( \"/\" , response_class = HTMLResponse ) async def root (): return \"\"\" <html> <body> <div>Everything works fine</div> </body> </html>\"\"\" @app . post ( \"/\" ) async def situation ( payload : dict ): print ( payload ) return You can check that everything works fine by running the server: uv run fastapi dev Then, open your browser and go to http://127.0.0.1:8000/ . Now, let us try to send data to this backend. On a new terminal, get the latest binary: curl -sLo ./situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation and run it with the following command: ./situation --http --http-url = http://127.0.0.1:8000/ On the server, you should see the payload printed in the terminal. Security You can add some security to the endpoint by authorizing only our agent. By default the agent sends its id in the Authorization header. To ensure you have a unique id, you can use the refresh-id command to regenerate it. ./situation refresh-id # regenerate an id ./situation id > .authorized_id # store the id to a local file Now restrict the access to the endpoint: from fastapi import Depends , FastAPI from fastapi.security import APIKeyHeader app = FastAPI () authorized_id = open ( \".authorized_id\" ) . read () . strip ( \" \\n \" ) auth = APIKeyHeader ( name = \"authorization\" ) # ... @app . post ( \"/\" ) async def situation ( payload : dict , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) print ( payload ) print ( agent_id ) return You can check that the endpoint is now protected. curl -X POST \\ -H 'Authorization: 00000000-0000-0000-0000-000000000000' \\ -H 'Content-Type: application/json' \\ --data '{}' \\ 'http://127.0.0.1:8000/' Payload integrity Currently, the endpoint can accept any payload. Fortunately, the agent comes with a json-schema that describes what it sends. We will use it to validate what we receive. The idea is to create a pydantic model that will validate the payload. To turn the json-schema into a pydantic model, we can use datamodel-code-generator . uv add --group dev datamodel-code-generator Then, we can generate the model ( models.py ) with the following command: uv run datamodel-codegen \\ --url 'https://github.com/situation-sh/situation/releases/download/v0.19.2/schema.json' \\ --input-file-type jsonschema \\ --output = models.py \\ --output-model-type pydantic_v2.BaseModel \\ --use-annotated \\ --use-union-operator \\ --use-field-description \\ --reuse-model \\ --collapse-root-models Instead of using dict we now have fully parsed model. from models import Payload # ... @app . post ( \"/\" ) async def situation ( payload : Payload , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) print ( payload ) print ( agent_id ) return You can re-run the agent and also check that you can't send anything to the endpoint. The following request returns a 422 error. curl -X POST \\ -H \"Authorization: $( cat .authorized_id ) \" \\ -H 'Content-Type: application/json' \\ --data '{\"foo\": \"bar\"}' \\ 'http://127.0.0.1:8000/' Going further Finally, you are free to use the data as you want. In this last example, we will list all the received records in a table. We start by creating a template for the HTML page. We will use Jinja2 to render the page. mkdir -p templates touch templates/index.html The content of the template is: <!DOCTYPE html> < html lang = \"en\" > < head > < link rel = \"preconnect\" href = \"https://fonts.googleapis.com\" > < link rel = \"preconnect\" href = \"https://fonts.gstatic.com\" crossorigin > < link href = \"https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap\" rel = \"stylesheet\" > < style > body { width : 100 vw ; height : 100 vh ; overflow : hidden ; font-family : \"Geist\" , sans-serif ; } article { max-width : 1200 px ; margin : 0 auto ; width : 100 % ; } h1 { font-size : 2.5 rem ; font-weight : 800 ; } . container { width : 100 % ; height : 100 % ; display : flex ; flex-direction : column ; } . table-wrapper { width : 100 % ; height : 100 % ; max-height : 70 vh ; overflow : auto ; font-family : \"Geist Mono\" , monospace ; font-size : small ; } table { border-collapse : collapse ; } thead th { height : 1.5 rem ; border-bottom : 1 px solid lightgray ; min-width : 75 px ; text-align : left ; } td { vertical-align : middle ; padding : 0 2 px ; } </ style > </ head > < body > < article > < div class = \"container\" > < h1 > Situation x FastAPI </ h1 > < div class = \"table-wrapper\" > < table style = \"width: 100%\" > < thead > < tr > < th > Timestamp </ th > < th > Agent </ th > < th > Machines </ th > < th > Duration </ th > < th > Errors </ th > </ tr > </ thead > < tbody > {% for record in records %} < tr > < td > {{ record.extra.timestamp }} </ td > < td > {{ record.extra.agent }} </ td > < td > {{ record.machines|length }} </ td > < td > {{ \"%.3f\"|format(record.extra.duration / 1e9) }}s </ td > < td > < ul > {% for error in record.extra.errors %} < li >< b > {{ error.module }} </ b > : {{error.message}} </ li > {% endfor %} </ ul > </ td > </ tr > {% endfor %} </ tbody > </ table > </ div > </ div > </ article > </ body > </ html > Here is the update of main.py : from typing import List from fastapi import Depends , FastAPI , HTTPException , Request from fastapi.responses import HTMLResponse from fastapi.security import APIKeyHeader from fastapi.templating import Jinja2Templates from models import Payload app = FastAPI () templates = Jinja2Templates ( directory = \"templates\" ) authorized_id = open ( \".authorized_id\" ) . read () . strip ( \" \\n \" ) auth = APIKeyHeader ( name = \"Authorization\" ) # store all the payloads in memory records : List [ Payload ] = [] @app . get ( \"/\" , response_class = HTMLResponse ) async def root ( request : Request ): return templates . TemplateResponse ( request = request , name = \"index.html\" , context = { \"records\" : records }, ) @app . post ( \"/\" ) async def situation ( payload : Payload , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) records . append ( payload ) return","title":"FastAPI"},{"location":"10_guides/fastapi/#requirements","text":"Initialize a project with uv for instance. uv init situation-fastapi cd situation-fastapi Add some dependencies: uv add 'fastapi[standard]'","title":"Requirements"},{"location":"10_guides/fastapi/#first-steps","text":"Create a file main.py with the following content: # main.py from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI () @app . get ( \"/\" , response_class = HTMLResponse ) async def root (): return \"\"\" <html> <body> <div>Everything works fine</div> </body> </html>\"\"\" @app . post ( \"/\" ) async def situation ( payload : dict ): print ( payload ) return You can check that everything works fine by running the server: uv run fastapi dev Then, open your browser and go to http://127.0.0.1:8000/ . Now, let us try to send data to this backend. On a new terminal, get the latest binary: curl -sLo ./situation https://github.com/situation-sh/situation/releases/download/v0.19.2/situation-0.19.2-amd64-linux chmod +x ./situation and run it with the following command: ./situation --http --http-url = http://127.0.0.1:8000/ On the server, you should see the payload printed in the terminal.","title":"First steps"},{"location":"10_guides/fastapi/#security","text":"You can add some security to the endpoint by authorizing only our agent. By default the agent sends its id in the Authorization header. To ensure you have a unique id, you can use the refresh-id command to regenerate it. ./situation refresh-id # regenerate an id ./situation id > .authorized_id # store the id to a local file Now restrict the access to the endpoint: from fastapi import Depends , FastAPI from fastapi.security import APIKeyHeader app = FastAPI () authorized_id = open ( \".authorized_id\" ) . read () . strip ( \" \\n \" ) auth = APIKeyHeader ( name = \"authorization\" ) # ... @app . post ( \"/\" ) async def situation ( payload : dict , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) print ( payload ) print ( agent_id ) return You can check that the endpoint is now protected. curl -X POST \\ -H 'Authorization: 00000000-0000-0000-0000-000000000000' \\ -H 'Content-Type: application/json' \\ --data '{}' \\ 'http://127.0.0.1:8000/'","title":"Security"},{"location":"10_guides/fastapi/#payload-integrity","text":"Currently, the endpoint can accept any payload. Fortunately, the agent comes with a json-schema that describes what it sends. We will use it to validate what we receive. The idea is to create a pydantic model that will validate the payload. To turn the json-schema into a pydantic model, we can use datamodel-code-generator . uv add --group dev datamodel-code-generator Then, we can generate the model ( models.py ) with the following command: uv run datamodel-codegen \\ --url 'https://github.com/situation-sh/situation/releases/download/v0.19.2/schema.json' \\ --input-file-type jsonschema \\ --output = models.py \\ --output-model-type pydantic_v2.BaseModel \\ --use-annotated \\ --use-union-operator \\ --use-field-description \\ --reuse-model \\ --collapse-root-models Instead of using dict we now have fully parsed model. from models import Payload # ... @app . post ( \"/\" ) async def situation ( payload : Payload , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) print ( payload ) print ( agent_id ) return You can re-run the agent and also check that you can't send anything to the endpoint. The following request returns a 422 error. curl -X POST \\ -H \"Authorization: $( cat .authorized_id ) \" \\ -H 'Content-Type: application/json' \\ --data '{\"foo\": \"bar\"}' \\ 'http://127.0.0.1:8000/'","title":"Payload integrity"},{"location":"10_guides/fastapi/#going-further","text":"Finally, you are free to use the data as you want. In this last example, we will list all the received records in a table. We start by creating a template for the HTML page. We will use Jinja2 to render the page. mkdir -p templates touch templates/index.html The content of the template is: <!DOCTYPE html> < html lang = \"en\" > < head > < link rel = \"preconnect\" href = \"https://fonts.googleapis.com\" > < link rel = \"preconnect\" href = \"https://fonts.gstatic.com\" crossorigin > < link href = \"https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap\" rel = \"stylesheet\" > < style > body { width : 100 vw ; height : 100 vh ; overflow : hidden ; font-family : \"Geist\" , sans-serif ; } article { max-width : 1200 px ; margin : 0 auto ; width : 100 % ; } h1 { font-size : 2.5 rem ; font-weight : 800 ; } . container { width : 100 % ; height : 100 % ; display : flex ; flex-direction : column ; } . table-wrapper { width : 100 % ; height : 100 % ; max-height : 70 vh ; overflow : auto ; font-family : \"Geist Mono\" , monospace ; font-size : small ; } table { border-collapse : collapse ; } thead th { height : 1.5 rem ; border-bottom : 1 px solid lightgray ; min-width : 75 px ; text-align : left ; } td { vertical-align : middle ; padding : 0 2 px ; } </ style > </ head > < body > < article > < div class = \"container\" > < h1 > Situation x FastAPI </ h1 > < div class = \"table-wrapper\" > < table style = \"width: 100%\" > < thead > < tr > < th > Timestamp </ th > < th > Agent </ th > < th > Machines </ th > < th > Duration </ th > < th > Errors </ th > </ tr > </ thead > < tbody > {% for record in records %} < tr > < td > {{ record.extra.timestamp }} </ td > < td > {{ record.extra.agent }} </ td > < td > {{ record.machines|length }} </ td > < td > {{ \"%.3f\"|format(record.extra.duration / 1e9) }}s </ td > < td > < ul > {% for error in record.extra.errors %} < li >< b > {{ error.module }} </ b > : {{error.message}} </ li > {% endfor %} </ ul > </ td > </ tr > {% endfor %} </ tbody > </ table > </ div > </ div > </ article > </ body > </ html > Here is the update of main.py : from typing import List from fastapi import Depends , FastAPI , HTTPException , Request from fastapi.responses import HTMLResponse from fastapi.security import APIKeyHeader from fastapi.templating import Jinja2Templates from models import Payload app = FastAPI () templates = Jinja2Templates ( directory = \"templates\" ) authorized_id = open ( \".authorized_id\" ) . read () . strip ( \" \\n \" ) auth = APIKeyHeader ( name = \"Authorization\" ) # store all the payloads in memory records : List [ Payload ] = [] @app . get ( \"/\" , response_class = HTMLResponse ) async def root ( request : Request ): return templates . TemplateResponse ( request = request , name = \"index.html\" , context = { \"records\" : records }, ) @app . post ( \"/\" ) async def situation ( payload : Payload , agent_id : str = Depends ( auth )): if agent_id != authorized_id : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) records . append ( payload ) return","title":"Going further"},{"location":"10_guides/jq-one-liners/","text":"While situation aims to send collected data to a \"remote\" place for further analysis, its output can be quickly worked by basic cli tools like jq . Network discovery Linux situation --stdout | jq -r '.machines[] | .nics[] | .mac + \"\\t\" + .ip' Windows situation . exe - -stdout | jq -r '.machines[] | .nics[] | .mac + \\\"\\t\\\" + .ip' aa:f4:b5:eb:ba:71 192 .168.1.11 0e:de:c8:62:b5:1c 192 .168.1.54 18 :19:ba:91:b7:c7 192 .168.1.13 c1:d3:d2:ab:41:cb 192 .168.1.31 47 :20:7b:a3:fb:2b 192 .168.1.57 You can even put the results in a csv file: Linux situation --stdout | jq -r '.machines[] | .nics[] | [.mac,.ip] | @csv' > output.csv Windows situation . exe - -stdout | jq -r '.machines[] | .nics[] | [.mac,.ip] | @csv' > output . csv Open ports Linux situation --stdout | jq -r '(.machines[] | .packages[] | .applications[] | .endpoints[] | [.addr,(.port|tostring)+\"/\"+.protocol])|@tsv' Windows situation . exe - -stdout | jq -r '(.machines[] | .packages[] | .applications[] | .endpoints[] | [.addr,(.port|tostring)+\\\"/\\\"+.protocol])|@tsv' 192 .168.1.1 53 /tcp 192 .168.1.1 80 /tcp 192 .168.1.1 1287 /tcp 192 .168.1.11 139 /tcp 192 .168.1.11 445 /tcp 192 .168.1.11 22 /tcp 192 .168.1.54 80 /tcp 192 .168.1.13 53 /tcp 192 .168.1.13 80 /tcp 192 .168.1.13 22 /tcp 192 .168.1.13 443 /tcp List services Linux situation | jq -r '([\"Service\",\"Address\",\"Port\"]|(., map(length*\"-\"))), (.machines[]|select(.hosted_agent)|.packages[]|.applications[]|.name as $n|.endpoints[]|[$n,.addr,(.port|tostring)+\"/\"+.protocol])|@tsv' | column -ts $'\\t' Windows situation . exe | jq -r '([\\\"Service\\\",\\\"Address\\\",\\\"Port\\\"]), (.machines[]|select(.hosted_agent)|.packages[]|.applications[]|.name as $n|.endpoints[]|[$n,.addr,(.port|tostring)+\\\"/\\\"+.protocol])|@csv' | ConvertFrom-Csv Service Address Port ------- ------- ---- systemd-resolve 0 .0.0.0 5355 /tcp systemd-resolve :: 5355 /tcp6 rpcbind 0 .0.0.0 111 /tcp rpcbind :: 111 /tcp6 dnsmasq 192 .168.122.1 53 /tcp rpc.statd 0 .0.0.0 35645 /tcp rpc.statd :: 50443 /tcp6 systemd :: 6556 /tcp6 kdeconnectd :: 1716 /tcp6","title":"jq one-liners"},{"location":"10_guides/jq-one-liners/#network-discovery","text":"Linux situation --stdout | jq -r '.machines[] | .nics[] | .mac + \"\\t\" + .ip' Windows situation . exe - -stdout | jq -r '.machines[] | .nics[] | .mac + \\\"\\t\\\" + .ip' aa:f4:b5:eb:ba:71 192 .168.1.11 0e:de:c8:62:b5:1c 192 .168.1.54 18 :19:ba:91:b7:c7 192 .168.1.13 c1:d3:d2:ab:41:cb 192 .168.1.31 47 :20:7b:a3:fb:2b 192 .168.1.57 You can even put the results in a csv file: Linux situation --stdout | jq -r '.machines[] | .nics[] | [.mac,.ip] | @csv' > output.csv Windows situation . exe - -stdout | jq -r '.machines[] | .nics[] | [.mac,.ip] | @csv' > output . csv","title":"Network discovery"},{"location":"10_guides/jq-one-liners/#open-ports","text":"Linux situation --stdout | jq -r '(.machines[] | .packages[] | .applications[] | .endpoints[] | [.addr,(.port|tostring)+\"/\"+.protocol])|@tsv' Windows situation . exe - -stdout | jq -r '(.machines[] | .packages[] | .applications[] | .endpoints[] | [.addr,(.port|tostring)+\\\"/\\\"+.protocol])|@tsv' 192 .168.1.1 53 /tcp 192 .168.1.1 80 /tcp 192 .168.1.1 1287 /tcp 192 .168.1.11 139 /tcp 192 .168.1.11 445 /tcp 192 .168.1.11 22 /tcp 192 .168.1.54 80 /tcp 192 .168.1.13 53 /tcp 192 .168.1.13 80 /tcp 192 .168.1.13 22 /tcp 192 .168.1.13 443 /tcp","title":"Open ports"},{"location":"10_guides/jq-one-liners/#list-services","text":"Linux situation | jq -r '([\"Service\",\"Address\",\"Port\"]|(., map(length*\"-\"))), (.machines[]|select(.hosted_agent)|.packages[]|.applications[]|.name as $n|.endpoints[]|[$n,.addr,(.port|tostring)+\"/\"+.protocol])|@tsv' | column -ts $'\\t' Windows situation . exe | jq -r '([\\\"Service\\\",\\\"Address\\\",\\\"Port\\\"]), (.machines[]|select(.hosted_agent)|.packages[]|.applications[]|.name as $n|.endpoints[]|[$n,.addr,(.port|tostring)+\\\"/\\\"+.protocol])|@csv' | ConvertFrom-Csv Service Address Port ------- ------- ---- systemd-resolve 0 .0.0.0 5355 /tcp systemd-resolve :: 5355 /tcp6 rpcbind 0 .0.0.0 111 /tcp rpcbind :: 111 /tcp6 dnsmasq 192 .168.122.1 53 /tcp rpc.statd 0 .0.0.0 35645 /tcp rpc.statd :: 50443 /tcp6 systemd :: 6556 /tcp6 kdeconnectd :: 1716 /tcp6","title":"List services"},{"location":"20_modules/","text":"Linux Windows Root required Name Summary Dependencies Status appuser AppUserModule fills user information from the PID of an application netstat arp ARPModule reads internal ARP table to find network neighbors. ping chassis ChassisModule fills host chassis information host-basic docker DockerModule retrieves information about docker containers. host-network , tcp-scan dpkg DPKGModule reads package information from the dpkg package manager. host-basic , netstat host-basic HostBasicModule retrieves basic information about the host: hostid, architecture, platform, distribution, version and uptime host-cpu HostCPUModule retrieves host CPU info: model, vendor and the number of cores. host-basic host-disk HostDiskModule retrieves basic information about disk: name, model, size, type, controller and partitions. host-basic host-gpu HostGPUModule retrieves basic information about GPU: index, vendor and product name. host-basic host-network HostNetworkModule retrieves basic newtork information about the host: interfaces along with their mac, ip and mask (IPv4 and IPv6) host-basic ja4 JA4Module attempts JA4, JA4S and JA4X fingerprinting tls msi MSIModule creates models.Packages instance from the windows registry host-basic netstat NetstatModule aims to retrieve infos like the netstat command does It must be run as root to retrieve PID/process information. host-basic , host-network ping PingModule pings local networks to discover new hosts. host-network reverse-lookup ReverseLookupModule tries to get a hostname attached to a local IP address netstat rpm RPMModule reads package information from the rpm package manager. host-basic , netstat snmp SNMPModule Module to collect data through SNMP protocol. arp ssh SSHModule aims to retrieve info from remote ssh services. tcp-scan tcp-scan TCPScanModule tries to connect to neighbor TCP ports. arp tls TLSModule enrich endpoints with TLS information. tcp-scan zypper ZypperModule reads package information from the zypper package manager. host-basic , netstat","title":"Modules reference"},{"location":"20_modules/appuser/","text":"AppUserModule fills user information from the PID of an application Details On Linux, it uses the /proc/\\ /status entrypoint. On Windows, it calls OpenProcessToken , GetTokenInformation and LookupAccountSidW . On windows, even if the agent is run as administrator, it may not have the required privileges to scan some processes like wininit.exe, services.exe. Dependencies Standard library bufio errors fmt os os/user strconv strings syscall unsafe External","title":"App User"},{"location":"20_modules/appuser/#details","text":"On Linux, it uses the /proc/\\ /status entrypoint. On Windows, it calls OpenProcessToken , GetTokenInformation and LookupAccountSidW . On windows, even if the agent is run as administrator, it may not have the required privileges to scan some processes like wininit.exe, services.exe.","title":"Details"},{"location":"20_modules/appuser/#dependencies","text":"Standard library bufio errors fmt os os/user strconv strings syscall unsafe External","title":"Dependencies"},{"location":"20_modules/arp/","text":"ARPModule reads internal ARP table to find network neighbors. Details It does not send ARP requests but leverage the Ping module that is likely to update the local table. On Linux, it uses the Netlink API with the netlink library. On Windows, it calls GetIpNetTable2 . Dependencies Standard library encoding/binary fmt net syscall time unsafe External github.com/vishvananda/netlink golang.org/x/sys/windows","title":"ARP"},{"location":"20_modules/arp/#details","text":"It does not send ARP requests but leverage the Ping module that is likely to update the local table. On Linux, it uses the Netlink API with the netlink library. On Windows, it calls GetIpNetTable2 .","title":"Details"},{"location":"20_modules/arp/#dependencies","text":"Standard library encoding/binary fmt net syscall time unsafe External github.com/vishvananda/netlink golang.org/x/sys/windows","title":"Dependencies"},{"location":"20_modules/chassis/","text":"ChassisModule fills host chassis information Details Currently it only works under linux. It uses DBUS and the \"org.freedesktop.hostname1\" service to get the type of the chassis (like laptop, vm, desktop etc.) In the future it may rather rely on ghw but at that time it does not fully get the info on windows. Dependencies Standard library os External github.com/godbus/dbus/v5","title":"Chassis"},{"location":"20_modules/chassis/#details","text":"Currently it only works under linux. It uses DBUS and the \"org.freedesktop.hostname1\" service to get the type of the chassis (like laptop, vm, desktop etc.) In the future it may rather rely on ghw but at that time it does not fully get the info on windows.","title":"Details"},{"location":"20_modules/chassis/#dependencies","text":"Standard library os External github.com/godbus/dbus/v5","title":"Dependencies"},{"location":"20_modules/docker/","text":"DockerModule retrieves information about docker containers. Details It uses the official go client that performs HTTP queries either on port :2375 (on windows generally) or on UNIX sockets. We generally need some privileges to reads UNIX sockets, so it may require root privileges (the alternative is to belong to the docker group) Dependencies Standard library context fmt net runtime strings time External github.com/docker/docker/api/types github.com/docker/docker/api/types/container github.com/docker/docker/api/types/filters github.com/docker/docker/api/types/network github.com/docker/docker/client github.com/sirupsen/logrus","title":"Docker"},{"location":"20_modules/docker/#details","text":"It uses the official go client that performs HTTP queries either on port :2375 (on windows generally) or on UNIX sockets. We generally need some privileges to reads UNIX sockets, so it may require root privileges (the alternative is to belong to the docker group)","title":"Details"},{"location":"20_modules/docker/#dependencies","text":"Standard library context fmt net runtime strings time External github.com/docker/docker/api/types github.com/docker/docker/api/types/container github.com/docker/docker/api/types/filters github.com/docker/docker/api/types/network github.com/docker/docker/client github.com/sirupsen/logrus","title":"Dependencies"},{"location":"20_modules/dpkg/","text":"DPKGModule reads package information from the dpkg package manager. Details This module is relevant for distros that use dpkg, like debian, ubuntu and their derivatives. It only uses the standard library. It reads /var/log/dpkg.log and also files from /var/lib/dpkg/info/ . Dependencies Standard library bufio errors fmt os path/filepath strings time External","title":"DPKG"},{"location":"20_modules/dpkg/#details","text":"This module is relevant for distros that use dpkg, like debian, ubuntu and their derivatives. It only uses the standard library. It reads /var/log/dpkg.log and also files from /var/lib/dpkg/info/ .","title":"Details"},{"location":"20_modules/dpkg/#dependencies","text":"Standard library bufio errors fmt os path/filepath strings time External","title":"Dependencies"},{"location":"20_modules/host_basic/","text":"HostBasicModule retrieves basic information about the host: hostid, architecture, platform, distribution, version and uptime Details It heavily relies on the gopsutil library. Data Linux Windows hostname uname syscall GetComputerNameExW call arch uname syscall GetNativeSystemInfo call platform runtime.GOOS variable runtime.GOOS variable distribution scanning /etc/*-release files HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion* register keys distribution version scanning /etc/*-release files HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion* register keys hostid reading /sys/class/dmi/id/product_uuid , /etc/machine-id or /proc/sys/kernel/random/boot_id HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid register key uptime sysinfo syscall GetTickCount64 call Dependencies Standard library os time External github.com/google/uuid github.com/shirou/gopsutil/v4/host","title":"Host Basic"},{"location":"20_modules/host_basic/#details","text":"It heavily relies on the gopsutil library. Data Linux Windows hostname uname syscall GetComputerNameExW call arch uname syscall GetNativeSystemInfo call platform runtime.GOOS variable runtime.GOOS variable distribution scanning /etc/*-release files HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion* register keys distribution version scanning /etc/*-release files HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion* register keys hostid reading /sys/class/dmi/id/product_uuid , /etc/machine-id or /proc/sys/kernel/random/boot_id HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid register key uptime sysinfo syscall GetTickCount64 call","title":"Details"},{"location":"20_modules/host_basic/#dependencies","text":"Standard library os time External github.com/google/uuid github.com/shirou/gopsutil/v4/host","title":"Dependencies"},{"location":"20_modules/host_cpu/","text":"HostCPUModule retrieves host CPU info: model, vendor and the number of cores. Details It heavily relies on the gopsutil library. On Linux, it reads /proc/cpuinfo . On Windows it performs the win32_Processor WMI request On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root). Dependencies Standard library fmt strconv External github.com/shirou/gopsutil/v4/cpu","title":"Host CPU"},{"location":"20_modules/host_cpu/#details","text":"It heavily relies on the gopsutil library. On Linux, it reads /proc/cpuinfo . On Windows it performs the win32_Processor WMI request On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root).","title":"Details"},{"location":"20_modules/host_cpu/#dependencies","text":"Standard library fmt strconv External github.com/shirou/gopsutil/v4/cpu","title":"Dependencies"},{"location":"20_modules/host_disk/","text":"HostDiskModule retrieves basic information about disk: name, model, size, type, controller and partitions. Details It heavily relies on the ghw library. On Windows, it uses WMI requests: ps1 SELECT Caption, CreationClassName, Description, DeviceID, FileSystem, FreeSpace, Name, Size, SystemName FROM Win32_LogicalDisk ps1 SELECT DeviceId, MediaType FROM MSFT_PhysicalDisk ps1 SELECT Access, BlockSize, Caption, CreationClassName, Description, DeviceID, DiskIndex, Index, Name, Size, SystemName, Type FROM Win32_DiskPartition ps1 SELECT Antecedent, Dependent FROM Win32_LogicalDiskToPartition On Linux, it reads /sys/block/$DEVICE/** files. On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root). Dependencies Standard library fmt External github.com/jaypipes/ghw","title":"Host Disk"},{"location":"20_modules/host_disk/#details","text":"It heavily relies on the ghw library. On Windows, it uses WMI requests: ps1 SELECT Caption, CreationClassName, Description, DeviceID, FileSystem, FreeSpace, Name, Size, SystemName FROM Win32_LogicalDisk ps1 SELECT DeviceId, MediaType FROM MSFT_PhysicalDisk ps1 SELECT Access, BlockSize, Caption, CreationClassName, Description, DeviceID, DiskIndex, Index, Name, Size, SystemName, Type FROM Win32_DiskPartition ps1 SELECT Antecedent, Dependent FROM Win32_LogicalDiskToPartition On Linux, it reads /sys/block/$DEVICE/** files. On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root).","title":"Details"},{"location":"20_modules/host_disk/#dependencies","text":"Standard library fmt External github.com/jaypipes/ghw","title":"Dependencies"},{"location":"20_modules/host_gpu/","text":"HostGPUModule retrieves basic information about GPU: index, vendor and product name. Details It heavily relies on ghw . On Linux it reads /sys/class/drm/ folder. On Windows, it performs the following WMI query: ps1 SELECT Caption, CreationClassName, Description, DeviceID, Manufacturer, Name, PNPClass, PNPDeviceID FROM Win32_PnPEntity On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root). Dependencies Standard library fmt External github.com/jaypipes/ghw","title":"Host GPU"},{"location":"20_modules/host_gpu/#details","text":"It heavily relies on ghw . On Linux it reads /sys/class/drm/ folder. On Windows, it performs the following WMI query: ps1 SELECT Caption, CreationClassName, Description, DeviceID, Manufacturer, Name, PNPClass, PNPDeviceID FROM Win32_PnPEntity On windows 11, the local user account must have administrator permissions (it does not mean it must be run as root).","title":"Details"},{"location":"20_modules/host_gpu/#dependencies","text":"Standard library fmt External github.com/jaypipes/ghw","title":"Dependencies"},{"location":"20_modules/host_network/","text":"HostNetworkModule retrieves basic newtork information about the host: interfaces along with their mac, ip and mask (IPv4 and IPv6) Details It uses the go standard library. On Linux, it uses the Netlink API. On Windows, it calls GetAdaptersAddresses . Dependencies Standard library fmt net strings External github.com/libp2p/go-netroute","title":"Host Network"},{"location":"20_modules/host_network/#details","text":"It uses the go standard library. On Linux, it uses the Netlink API. On Windows, it calls GetAdaptersAddresses .","title":"Details"},{"location":"20_modules/host_network/#dependencies","text":"Standard library fmt net strings External github.com/libp2p/go-netroute","title":"Dependencies"},{"location":"20_modules/ja4/","text":"JA4Module attempts JA4, JA4S and JA4X fingerprinting Details For technical details you look at https://github.com/FoxIO-LLC/ja4/blob/main/technical_details/README.md It first look at TLS endpoints (given by the TLS module ) and then tries to connect to them, collecting then JA4, JA4S and JA4X fingerprints. Dependencies Standard library crypto/sha256 crypto/tls crypto/x509 crypto/x509/pkix encoding/asn1 encoding/binary encoding/hex fmt net slices strings time External","title":"JA4"},{"location":"20_modules/ja4/#details","text":"For technical details you look at https://github.com/FoxIO-LLC/ja4/blob/main/technical_details/README.md It first look at TLS endpoints (given by the TLS module ) and then tries to connect to them, collecting then JA4, JA4S and JA4X fingerprints.","title":"Details"},{"location":"20_modules/ja4/#dependencies","text":"Standard library crypto/sha256 crypto/tls crypto/x509 crypto/x509/pkix encoding/asn1 encoding/binary encoding/hex fmt net slices strings time External","title":"Dependencies"},{"location":"20_modules/msi/","text":"MSIModule creates models.Packages instance from the windows registry Details For system-wide apps, it looks at HKLM/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* and HKLM/WOW6432Node/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* for 32bits apps. For user-specific apps: HKCU/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* . Dependencies Standard library fmt io/fs os path/filepath strings sync time External github.com/sirupsen/logrus golang.org/x/sys/windows/registry","title":"MSI"},{"location":"20_modules/msi/#details","text":"For system-wide apps, it looks at HKLM/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* and HKLM/WOW6432Node/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* for 32bits apps. For user-specific apps: HKCU/SOFTWARE/Microsoft/Windows/CurrentVersion/Uninstall/* .","title":"Details"},{"location":"20_modules/msi/#dependencies","text":"Standard library fmt io/fs os path/filepath strings sync time External github.com/sirupsen/logrus golang.org/x/sys/windows/registry","title":"Dependencies"},{"location":"20_modules/netstat/","text":"NetstatModule aims to retrieve infos like the netstat command does It must be run as root to retrieve PID/process information. Details Without these data, it is rather hard to build reliable links between open ports and programs. This module is then able to create flows between applications according to the tuple (src, srcport, dst, dstport). On windows, the privileges are not checked (because we need to parse the SID or another thing maybe). So the module is always run. Dependencies Standard library os/user runtime External github.com/cakturk/go-netstat/netstat","title":"Netstat"},{"location":"20_modules/netstat/#details","text":"Without these data, it is rather hard to build reliable links between open ports and programs. This module is then able to create flows between applications according to the tuple (src, srcport, dst, dstport). On windows, the privileges are not checked (because we need to parse the SID or another thing maybe). So the module is always run.","title":"Details"},{"location":"20_modules/netstat/#dependencies","text":"Standard library os/user runtime External github.com/cakturk/go-netstat/netstat","title":"Dependencies"},{"location":"20_modules/ping/","text":"PingModule pings local networks to discover new hosts. Details The module relies on pro-bing library. A single ping attempt is made on every host of the local networks (the host may belong to several networks). Only IPv4 networks with prefix length >=20 are treated. The ping timeout is hardset to 300ms. Dependencies Standard library fmt net os/user regexp strconv strings sync time External github.com/lorenzosaino/go-sysctl github.com/prometheus-community/pro-bing github.com/sirupsen/logrus","title":"Ping"},{"location":"20_modules/ping/#details","text":"The module relies on pro-bing library. A single ping attempt is made on every host of the local networks (the host may belong to several networks). Only IPv4 networks with prefix length >=20 are treated. The ping timeout is hardset to 300ms.","title":"Details"},{"location":"20_modules/ping/#dependencies","text":"Standard library fmt net os/user regexp strconv strings sync time External github.com/lorenzosaino/go-sysctl github.com/prometheus-community/pro-bing github.com/sirupsen/logrus","title":"Dependencies"},{"location":"20_modules/reverse_lookup/","text":"ReverseLookupModule tries to get a hostname attached to a local IP address Details Dependencies Standard library net strings External","title":"Reverse Lookup"},{"location":"20_modules/reverse_lookup/#details","text":"","title":"Details"},{"location":"20_modules/reverse_lookup/#dependencies","text":"Standard library net strings External","title":"Dependencies"},{"location":"20_modules/rpm/","text":"RPMModule reads package information from the rpm package manager. Details This module is relevant for distros that use rpm, like fedora, redhat and their derivatives. It uses an sqlite client because of the way rpm works. It tries to read the rpm database: /var/lib/rpm/rpmdb.sqlite . Otherwise, it will try to find the rpmdb.sqlite file inside /usr/lib . Dependencies Standard library bytes database/sql encoding/binary fmt io/fs path path/filepath time unicode/utf8 External modernc.org/sqlite","title":"RPM"},{"location":"20_modules/rpm/#details","text":"This module is relevant for distros that use rpm, like fedora, redhat and their derivatives. It uses an sqlite client because of the way rpm works. It tries to read the rpm database: /var/lib/rpm/rpmdb.sqlite . Otherwise, it will try to find the rpmdb.sqlite file inside /usr/lib .","title":"Details"},{"location":"20_modules/rpm/#dependencies","text":"Standard library bytes database/sql encoding/binary fmt io/fs path path/filepath time unicode/utf8 External modernc.org/sqlite","title":"Dependencies"},{"location":"20_modules/snmp/","text":"SNMPModule Module to collect data through SNMP protocol. Details This module need to access the following OID TREE: .1.3.6.1.2.1 In case of snmpd, the configuration (snmpd.conf) should then include something like this: conf view systemonly included .1.3.6.1.2.1 Dependencies Standard library context errors fmt net strconv strings sync time External github.com/gosnmp/gosnmp github.com/sirupsen/logrus","title":"SNMP"},{"location":"20_modules/snmp/#details","text":"This module need to access the following OID TREE: .1.3.6.1.2.1 In case of snmpd, the configuration (snmpd.conf) should then include something like this: conf view systemonly included .1.3.6.1.2.1","title":"Details"},{"location":"20_modules/snmp/#dependencies","text":"Standard library context errors fmt net strconv strings sync time External github.com/gosnmp/gosnmp github.com/sirupsen/logrus","title":"Dependencies"},{"location":"20_modules/ssh/","text":"SSHModule aims to retrieve info from remote ssh services. Details It mainly tries to connect to open tcp/22 ports, gathering everything it can like the host_key and the algorithms available. In the OpenSSH case it also tries to parse the banner to get product and OS infos (versions notably) Dependencies Standard library encoding/json fmt net regexp strings time External github.com/praetorian-inc/fingerprintx/pkg/plugins github.com/praetorian-inc/fingerprintx/pkg/plugins/services/ssh","title":"SSH"},{"location":"20_modules/ssh/#details","text":"It mainly tries to connect to open tcp/22 ports, gathering everything it can like the host_key and the algorithms available. In the OpenSSH case it also tries to parse the banner to get product and OS infos (versions notably)","title":"Details"},{"location":"20_modules/ssh/#dependencies","text":"Standard library encoding/json fmt net regexp strings time External github.com/praetorian-inc/fingerprintx/pkg/plugins github.com/praetorian-inc/fingerprintx/pkg/plugins/services/ssh","title":"Dependencies"},{"location":"20_modules/tcp_scan/","text":"TCPScanModule tries to connect to neighbor TCP ports. Details The module only uses the Go standard library. A TCP connect is performed on the NMAP top 1000 ports . These connection attempts are made concurrently against the hosts previously found. The connections have a 500ms timeout. Dependencies Standard library fmt net sync time External","title":"TCP Scan"},{"location":"20_modules/tcp_scan/#details","text":"The module only uses the Go standard library. A TCP connect is performed on the NMAP top 1000 ports . These connection attempts are made concurrently against the hosts previously found. The connections have a 500ms timeout.","title":"Details"},{"location":"20_modules/tcp_scan/#dependencies","text":"Standard library fmt net sync time External","title":"Dependencies"},{"location":"20_modules/tls/","text":"TLSModule enrich endpoints with TLS information. Details The module only uses the Go standard library. Currently it only supports TLS over TCP. Dependencies Standard library crypto/sha1 crypto/sha256 crypto/tls encoding/hex fmt net External","title":"TLS"},{"location":"20_modules/tls/#details","text":"The module only uses the Go standard library. Currently it only supports TLS over TCP.","title":"Details"},{"location":"20_modules/tls/#dependencies","text":"Standard library crypto/sha1 crypto/sha256 crypto/tls encoding/hex fmt net External","title":"Dependencies"},{"location":"20_modules/zypper/","text":"ZypperModule reads package information from the zypper package manager. Details This module is relevant for distros that use zypper, like suse and their derivatives. It uses go-rpmdb . It reads /var/lib/rpm/Packages.db . Dependencies Standard library fmt time External github.com/knqyf263/go-rpmdb/pkg","title":"Zypper"},{"location":"20_modules/zypper/#details","text":"This module is relevant for distros that use zypper, like suse and their derivatives. It uses go-rpmdb . It reads /var/lib/rpm/Packages.db .","title":"Details"},{"location":"20_modules/zypper/#dependencies","text":"Standard library fmt time External github.com/knqyf263/go-rpmdb/pkg","title":"Dependencies"},{"location":"99_developer/","text":"The Situation project aims to be enriched by the community, and modules are definitely a good starting point for developers to contribute. Before detailing the internals of Situation, it is paramount to understand the overall spirit of the project. No user interaction : it means that the agent must run without configuration, without integration, without dependency. In some cases, we obviously need some extra information. In this project, the developer should code enough logic to guess what is missing. For instance, if you want to detect a database, you need to guess what could be its listening port. Fortunately, modules also provide data that could be useful for subsequent modules through the store . So developers should well define their dependencies to ease the workflow of their module. Basically, we should avoid to do twice the same thing. Security : yes it is hard to ensure at 100%. However, for this kind of project, we quickly feel like using exec.Command and other shortcuts that ease developers' job (but decrease security level). So, do not use exec.Command and do not use library that uses it. In nutshell, we should keep in mind that this agent is likely to run with root privileges on critical systems.","title":"Overview"},{"location":"99_developer/architecture/","text":"The agent is divided into several modules. Module Job backends all the possible outputs (like stdout, file, databases...) config central app configuration cmd agent entrypoint (it basically manages the run of the agent) models definition of the models that represent what could be discovered modules all the collectors store internal payload where all the retrieved information are stored utils extra helpers The overall architecture is quite classical for plugin-based tools. An orchestrator schedules and runs the available modules and all the collected data can be sent in the backend you want. architecture @font-face { font-family: Excalifont; src: url(data:font/woff2;base64,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); } CMD CONFIG MODULES define defaults update from flags read STORE read/write run (scheduler)","title":"Architecture"},{"location":"99_developer/contributing/","text":"When contributing to this project, please first discuss the change you wish to make via Github issue . The issue should be enough documented to well understand the bug or the requested feature. License All the code submitted in this project follows the project LICENSE . MR Process Fork the project into your personal namespace (or group) on Github. Create a feature branch in your fork with naming <issue-id>-<lowercase-title-of-the-issue> . Make changes (code, docs...) Ensure the documentation is updated ( docs/ folder) Push the commits to your feature branch in your fork. Submit a pull request (PR) to the main branch in the main Github project. Coding Style Taken from moby/moby Unless explicitly stated, we follow all coding guidelines from the Go community. While some of these standards may seem arbitrary, they somehow seem to result in a solid, consistent codebase. It is possible that the code base does not currently comply with these guidelines. We are not looking for a massive PR that fixes this, since that goes against the spirit of the guidelines. All new contributions should make a best effort to clean up and make the code base better than they left it. Obviously, apply your best judgement. Remember, the goal here is to make the code base easier for humans to navigate and understand. Always keep that in mind when nudging others to comply. If you are having trouble getting into the mood of idiomatic Go, we recommend reading through Effective Go . The Go Blog is also a great resource. Drinking the kool-aid is a lot easier than going thirsty.","title":"Contributing"},{"location":"99_developer/contributing/#license","text":"All the code submitted in this project follows the project LICENSE .","title":"License"},{"location":"99_developer/contributing/#mr-process","text":"Fork the project into your personal namespace (or group) on Github. Create a feature branch in your fork with naming <issue-id>-<lowercase-title-of-the-issue> . Make changes (code, docs...) Ensure the documentation is updated ( docs/ folder) Push the commits to your feature branch in your fork. Submit a pull request (PR) to the main branch in the main Github project.","title":"MR Process"},{"location":"99_developer/contributing/#coding-style","text":"Taken from moby/moby Unless explicitly stated, we follow all coding guidelines from the Go community. While some of these standards may seem arbitrary, they somehow seem to result in a solid, consistent codebase. It is possible that the code base does not currently comply with these guidelines. We are not looking for a massive PR that fixes this, since that goes against the spirit of the guidelines. All new contributions should make a best effort to clean up and make the code base better than they left it. Obviously, apply your best judgement. Remember, the goal here is to make the code base easier for humans to navigate and understand. Always keep that in mind when nudging others to comply. If you are having trouble getting into the mood of idiomatic Go, we recommend reading through Effective Go . The Go Blog is also a great resource. Drinking the kool-aid is a lot easier than going thirsty.","title":"Coding Style"},{"location":"99_developer/modules/","text":"Introduction A module is an independent piece of code that can be run during scan. Its job is merely to enrich the store. It is not fully independent as it may depend on previous modules (some module are likely to need data provided by others). To develop a module, just init a new my_new_module.go source file in the modules/ subdirectory. The structure of the module should look like the following snippet. package modules import ( // ... ) type MyNewModule struct { Attribute string } func init () { m := & MyNewModule { Attribute : \"defultValue\" } RegisterModule ( m ) // bind attributes with configuration variable (the attribute will be exposed to CLI flags) SetDefault ( m , \"attribute\" , & m . Attribute , \"Custom attribute for my new module\" ) } // Name returns the name of the module func ( m * MyNewModule ) Name () string { // return the name of the module with a dash return \"my-new-module\" } // Dependencies return the list of modules // required to run this one func ( m * MyNewModule ) Dependencies () [] string { // put the name of the modules you depend on here return [] string { \"host-basic\" } } // Run do the job. It returns error only if it really // fails, i.e. it cannot be run (like privileges). // In the other cases, just log the errors func ( m * MyNewModule ) Run () error { // you can grab your logger (from https://github.com/Sirupsen/logrus) logger := GetLogger ( m ) // ... // do what you want // ... // but do not return error except if something // prevents the module to be run, just log them: // logger.Error(err) // ... // // don't forget to put data into the store // ... return nil } Naming You are free about the module naming, but obviously there are some constraints: the module name must be unique the name should describe what the module does (or the ecosystem, like \"docker\") If you want to create a module called \"awesome stuff\": its name (output of .Name() ) must be awesome-stuff the object that respects the Module interface must be AwesomeStuffModule the source file must be awesome_stuff.go Module interface A module must implement the Module interface described below. // Module is the generic module interface to implement plugins to // the agent type Module interface { Name () string Dependencies () [] string Run () error } The Name() outputs the unique name of the module. The Dependencies() returns the names of the modules required to start this module (prior information). The Run() function does the job. This functions is called during the scan. It may have several interactions: config (get extra configuration data) logging (output some information about the run) store (retrieve/store collected data) Configuration The configuration is managed by asiffer/puzzle . As the example above, you should put the required information into the base module struct, along with a relevant default value. If you want to let the user modify attributes, you should bind your struct attribute with the configuration, through the following helper: // SetDefault is a helper that defines default module parameter. // The provided values can be overwritten by CLI flags, env variables or anything // the asiffer/puzzle library may support. func SetDefault [ T any ]( m Module , key string , value * T , usage string ) { // ... } The configuration of the modules are stored in the modules.module-name.* namespace in the config module, so it can be accessed by other modules through config.Get[T](key string) . In your code (like in the Run() function), you should directly access the attributes through the pointer receiver. func ( m * MyNewModule ) Run () error { // do not get it through the config attr , err := config . Get [ string ]( \"modules.my-new-module.attribute\" ) // rather access it directly attr := m . Attribute } Logging The logging is managed by logrus . To log some information, the modules package expose a GetLogger function that returns a contextual logger (relative to the module). func ( m * MyModule ) Run () error { // ... logger := GetLogger ( m ) // now you can use the classical methods logger . Debug ( \"Debug message\" ) logger . Info ( \"Info message\" ) logger . Warn ( \"Warning message\" ) logger . Error ( \"Error message\" ) logger . Fatal ( \"Fatal error\" ) // you should avoid logger.Panic to prevent the agent from crashing // ... } In addition, the module is likely to collect some information. You can log the collected data in a structured manner with the logger.WithField method. func ( m * MyModule ) Run () error { // ... logger := GetLogger ( m ) // ... // append the fields you want to show and call Debug/Info method logger . WithField ( \"hostname\" , hostname ). Debug ( \"Hostname found!\" ) } Big module case if your module is heavy you can store all the work (namely the material for the Run function) inside a submodule and write a short interface in the modules directory. You may have the following layout: modules/ heavy.go heavy/ file1.go file2.go ... The heavy.go file may look like the following: import ( // ... // load the submodule \"github.com/situation-sh/situation/modules/heavy\" ) type HeavyModule struct {} func init () { RegisterModule ( & HeavyModule {}) } func ( m * HeavyModule ) Name () string { // return the name of the module with a dash return \"heavy\" } func ( m * HeavyModule ) Dependencies () [] string { // put the name of the modules you depend on here return [] string {} } func ( m * HeavyModule ) Run () error { // ... // call heavy.Stuff // ... } Documentation Documenting a module is mandatory. There are two things to do. The first thing is to document the Module object as follows: // MyNewModule retrieves data from ... // // It mainly depends on the following external library: // - ... // // On Windows, it collect data by calling... // On Linux, it reads ... type MyNewModule struct {} One must have a synospis (first line) and then some details about the module. One may include how data is collected with regards to the platform and also other relevant things (edge cases, libraries, privileges, options etc.) The second point is to fill some standard notes, as follows: // LINUX(MyNewModule) ok // WINDOWS(MyNewModule) ok // MACOS(MyNewModule) ? // ROOT(MyNewModule) no package modules The format of the note is given by the doc package. We use it as follows: <KEY>(<MODULE-NAME>) <VALUE> Currently there are 4 attributes to provide: LINUX , WINDOWS , MACOS and ROOT . Their corresponding values must be yes / ok (meaning \"supported\"), no (meaning \"not supported\"), or ? (meaning \"don't know\"). For ROOT , yes / ok means that root privileges are required","title":"Module"},{"location":"99_developer/modules/#introduction","text":"A module is an independent piece of code that can be run during scan. Its job is merely to enrich the store. It is not fully independent as it may depend on previous modules (some module are likely to need data provided by others). To develop a module, just init a new my_new_module.go source file in the modules/ subdirectory. The structure of the module should look like the following snippet. package modules import ( // ... ) type MyNewModule struct { Attribute string } func init () { m := & MyNewModule { Attribute : \"defultValue\" } RegisterModule ( m ) // bind attributes with configuration variable (the attribute will be exposed to CLI flags) SetDefault ( m , \"attribute\" , & m . Attribute , \"Custom attribute for my new module\" ) } // Name returns the name of the module func ( m * MyNewModule ) Name () string { // return the name of the module with a dash return \"my-new-module\" } // Dependencies return the list of modules // required to run this one func ( m * MyNewModule ) Dependencies () [] string { // put the name of the modules you depend on here return [] string { \"host-basic\" } } // Run do the job. It returns error only if it really // fails, i.e. it cannot be run (like privileges). // In the other cases, just log the errors func ( m * MyNewModule ) Run () error { // you can grab your logger (from https://github.com/Sirupsen/logrus) logger := GetLogger ( m ) // ... // do what you want // ... // but do not return error except if something // prevents the module to be run, just log them: // logger.Error(err) // ... // // don't forget to put data into the store // ... return nil }","title":"Introduction"},{"location":"99_developer/modules/#naming","text":"You are free about the module naming, but obviously there are some constraints: the module name must be unique the name should describe what the module does (or the ecosystem, like \"docker\") If you want to create a module called \"awesome stuff\": its name (output of .Name() ) must be awesome-stuff the object that respects the Module interface must be AwesomeStuffModule the source file must be awesome_stuff.go","title":"Naming"},{"location":"99_developer/modules/#module-interface","text":"A module must implement the Module interface described below. // Module is the generic module interface to implement plugins to // the agent type Module interface { Name () string Dependencies () [] string Run () error } The Name() outputs the unique name of the module. The Dependencies() returns the names of the modules required to start this module (prior information). The Run() function does the job. This functions is called during the scan. It may have several interactions: config (get extra configuration data) logging (output some information about the run) store (retrieve/store collected data)","title":"Module interface"},{"location":"99_developer/modules/#configuration","text":"The configuration is managed by asiffer/puzzle . As the example above, you should put the required information into the base module struct, along with a relevant default value. If you want to let the user modify attributes, you should bind your struct attribute with the configuration, through the following helper: // SetDefault is a helper that defines default module parameter. // The provided values can be overwritten by CLI flags, env variables or anything // the asiffer/puzzle library may support. func SetDefault [ T any ]( m Module , key string , value * T , usage string ) { // ... } The configuration of the modules are stored in the modules.module-name.* namespace in the config module, so it can be accessed by other modules through config.Get[T](key string) . In your code (like in the Run() function), you should directly access the attributes through the pointer receiver. func ( m * MyNewModule ) Run () error { // do not get it through the config attr , err := config . Get [ string ]( \"modules.my-new-module.attribute\" ) // rather access it directly attr := m . Attribute }","title":"Configuration"},{"location":"99_developer/modules/#logging","text":"The logging is managed by logrus . To log some information, the modules package expose a GetLogger function that returns a contextual logger (relative to the module). func ( m * MyModule ) Run () error { // ... logger := GetLogger ( m ) // now you can use the classical methods logger . Debug ( \"Debug message\" ) logger . Info ( \"Info message\" ) logger . Warn ( \"Warning message\" ) logger . Error ( \"Error message\" ) logger . Fatal ( \"Fatal error\" ) // you should avoid logger.Panic to prevent the agent from crashing // ... } In addition, the module is likely to collect some information. You can log the collected data in a structured manner with the logger.WithField method. func ( m * MyModule ) Run () error { // ... logger := GetLogger ( m ) // ... // append the fields you want to show and call Debug/Info method logger . WithField ( \"hostname\" , hostname ). Debug ( \"Hostname found!\" ) }","title":"Logging"},{"location":"99_developer/modules/#big-module-case","text":"if your module is heavy you can store all the work (namely the material for the Run function) inside a submodule and write a short interface in the modules directory. You may have the following layout: modules/ heavy.go heavy/ file1.go file2.go ... The heavy.go file may look like the following: import ( // ... // load the submodule \"github.com/situation-sh/situation/modules/heavy\" ) type HeavyModule struct {} func init () { RegisterModule ( & HeavyModule {}) } func ( m * HeavyModule ) Name () string { // return the name of the module with a dash return \"heavy\" } func ( m * HeavyModule ) Dependencies () [] string { // put the name of the modules you depend on here return [] string {} } func ( m * HeavyModule ) Run () error { // ... // call heavy.Stuff // ... }","title":"Big module case"},{"location":"99_developer/modules/#documentation","text":"Documenting a module is mandatory. There are two things to do. The first thing is to document the Module object as follows: // MyNewModule retrieves data from ... // // It mainly depends on the following external library: // - ... // // On Windows, it collect data by calling... // On Linux, it reads ... type MyNewModule struct {} One must have a synospis (first line) and then some details about the module. One may include how data is collected with regards to the platform and also other relevant things (edge cases, libraries, privileges, options etc.) The second point is to fill some standard notes, as follows: // LINUX(MyNewModule) ok // WINDOWS(MyNewModule) ok // MACOS(MyNewModule) ? // ROOT(MyNewModule) no package modules The format of the note is given by the doc package. We use it as follows: <KEY>(<MODULE-NAME>) <VALUE> Currently there are 4 attributes to provide: LINUX , WINDOWS , MACOS and ROOT . Their corresponding values must be yes / ok (meaning \"supported\"), no (meaning \"not supported\"), or ? (meaning \"don't know\"). For ROOT , yes / ok means that root privileges are required","title":"Documentation"},{"location":"99_developer/store/","text":"The Store is the internal memory where the agent put collected data. It has an internal structure with some helpers we advise to use. The store is closely related to the models defined in the models module. The store can be filled and queried as well (we try to make it thread-safe ). Basically, the store is a list of machines ( models.Machine ), so you may look for machines (to get information or to enrich it) or merely insert new ones. Warning The store and the models are rather instable. Especially, developers are likely to update the models (add/modify/remove attribute). Even if some functions help hiding the details, some changes can obviously have a wide impact.","title":"Store"}]}